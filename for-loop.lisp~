(defpackage for-loop
  (:use :cl))
(in-package for-loop)

(defun for-collect-clauses (bindings)
  (let* ((r (list nil))
         (tail r)
         last-do-p this-do-p)
    (flet ((collect (&rest items)
             (dolist (i items)
               (rplacd tail (setf tail (list i)))))
           (same (s1 s2)
             (when (and (or (symbolp s1) (stringp s1))
                        (or (symbolp s2) (stringp s2)))
               (string-equal s1 s2))))
      (declare (inline collect))
      (symbol-macrolet ((1st (first binding))
                        (2nd (second binding))
                        (3rd (third binding))
                        (4th (fourth binding))
                        (5th (fifth binding))
                        (6th (sixth binding))
                        (7th (seventh binding)))
        (macrolet ((clause (binding-length &rest sames)
                     (nconc `(and (= (length binding) ,binding-length))
                            (loop for (val1 val2) in sames collect `(same ,val1 ',val2)))))
          (prog ((binding (car bindings)))
            start-loop
            (cond ((and (>= (length binding) 2) (same 2nd :range))
                   (cond ((clause 2)
                          (collect :for 1st :from 0))
                         ((clause 4 (3rd by))
                          (collect :for 1st :from 0 :by 4th))
                         ((clause 3)
                          (collect :for 1st :to 3rd))
                         ((clause 4)
                          (collect :for 1st :from 3rd :to 4th))
                         ((clause 5 (4th by))
                          (collect :for 1st :from 3rd :by 5th))
                         ((clause 5)
                          (collect :for 1st :from 3rd :to 4th :by 5th))
                         ((clause 6 (5th by))
                          (collect :for 1st :from 3rd :by 4th :by 6th))
                         (t (go from-to))))
                  ((and (>= (length binding) 3) (same 3rd :range))
                   (cond ((clause 3)
                          (collect :for 1st :of-type 2nd :from 0))
                         ((clause 5 (4th by))
                          (collect :for 1st :of-type 2nd :from 0 :by 5th))
                         ((clause 4)
                          (collect :for 1st :of-type 2nd :to 3rd))
                         ((clause 5)
                          (collect :for 1st :of-type 2nd :from 4th :to 5th))
                         ((clause 6 (5th by))
                          (collect :for 1st :of-type 2nd :from 4th :by 6th))
                         ((clause 6)
                          (collect :for 1st :of-type 2nd :from 4th :to 5th :by 6th))
                         ((clause 7 (6th by))
                          (collect :for 1st :of-type 2nd :from 4th :by 5th :by 7th))
                         (t (go from-to)))))
            (go next-loop)
            from-to
            (when (and (> (length binding) 3) (or (member 2nd '("FROM" "TO" "BY") :test #'same)))
              (apply #'collect binding)
              (go next-loop))
            list-type
            (cond ((clause 4 (3rd in-plist))
                   (collect :for (list 1st 2nd) :on 4th :by #'cddr))
                  ((clause 5 (4th in-plist))
                   (collect :for 1st :from 0 :for (list 2nd 3rd) :on 5th :by #'cddr))
                  ((clause 4 (3rd in-alist))
                   (collect :for (cons 1st 2nd) :on 4th))
                  ((clause 5 (4th in-alist))
                   (collect :for 1st :from 0 :for (cons 2nd 3rd) :on 5th))
                  (t (go tables)))
            (go next-loop)
            tables
            (when (>= (length binding) 3)
              (cond ((member 2nd '("HASH-KEY" "HASH-KEYS" "IN-HASH-KEY" "IN-HASH-KEYS" "TABLE-KEYS") :test #'same)
                     (collect :for 1st :being :each :hash-key :of 3rd))
                    ((member 2nd '("HASH-VALUE" "HASH-VALUES" "IN-HASH-VALUE" "IN-HASH-VALUES" "TABLE-VALUES") :test #'same)
                     (collect :for 1st :being :each :hash-value :of 3rd))
                    ((and (clause 4) (member 3rd '("TABLE" "HASHTABLE" "TABLE-PAIRS" "HASH-TABLE" "IN-TABLE" "IN-HASHTABLE" "IN-HASH-TABLE") :test #'same))
                     (collect :for 1st :being :each :hash-key :of 4th :for 2nd := `(gethash ,1st ,4th)))
                    (t (go in)))
              (go next-loop))
            in
            (cond ((clause 3 (2nd in))
                   (if (clause 5 (4th by))
                       (collect :for 1st :in 3rd :by 5th)
                     (collect :for 1st :in 3rd)))
                  ((clause 4 (3rd in))
                   (if (clause 6 (5th by))
                       (collect :for 1st :of-type 2nd :in 4th :by 6th)
                     (collect :for 1st :of-type 2nd :in 4th)))
                  ((same 2nd "ON")
                   (if (clause 5 (4th by))
                       (collect :for 1st :on 3rd :by 5th)
                     (collect :for 1st :on 3rd)))
                  ((same 3rd "ON")
                   (if (clause 6 (5th by))
                       (collect :for 1st :of-type 2nd :on 4th :by 6th)
                     (collect :for 1st :of-type 2nd :on 4th)))
                  (t (go across)))
            (go next-loop)
            across
            (cond ((clause 3 (2nd across))
                   (collect :for 1st :across 3rd))
                  ((clause 4 (3rd across))
                   (collect :for 1st :of-type 2nd :across 4th))
                  (t (go equal)))
            (go next-loop)
            equal
            (cond ((clause 4 (3rd then))
                   (collect :for 1st := 2nd :then 4th))
                  ((clause 5 (4th then))
                   (collect :for 1st :of-type 2nd := 3rd :then 5th))
                  ((clause 3 (2nd =))
                   (if (clause 5 (4th then))
                       (collect :for 1st := 3rd :then 5th)
                     (collect :for 1st := 3rd)))
                  ((clause 4 (3rd =))
                   (if (clause 6 (5th then))
                       (collect :for 1st :of-type 2nd := 4th :then 6th)
                     (collect :for 1st :of-type 2nd := 4th)))
                  (t (go previous)))
            (go next-loop)
            previous
            (cond ((clause 3 (2nd previous))
                   (setf (cdr r) (nconc (list :for 1st := nil :then 3rd) (cdr r))))
                  ((clause 4 (2nd previous))
                   (setf (cdr r) (nconc (list :for 1st := 4th :then 3rd) (cdr r))))
                  ((clause 4 (3rd previous))
                   (setf (cdr r) (nconc (list :for 1st :of-type 2nd := nil :then 4th) (cdr r))))
                  ((clause 5 (3rd previous))
                   (setf (cdr r) (nconc (list :for 1st :of-type 2nd := 5th :then 4th) (cdr r))))
                  (t (go package)))
            package
            (when (clause 4 (3rd in-package))
              (collect :for 2nd :being :each 1st :of 4th)
              (go next-loop))
            init-final-clauses
            (cond ((member 1st '("INIT" "INITIALLY") :test #'same)
                   (collect :initially (cons 'progn (cdr binding))))
                  ((member 1st '("FINAL" "FINALLY") :test #'same)
                   (collect :finally `(return (progn ,@(cdr binding)))))
                  (t (go accumulate-clauses)))
            (go next-loop)
            accumulate-clauses
            (when (member 1st '("COUNT" "COUNTING" "SUM" "SUMMING" "COLLECT" "COLLECTING"
                                "APPEND" "APPENDING" "NCONC" "NCONCING"
                                "MAXIMIZE" "MAXIMIZING" "MINIMIZE" "MINIMIZING")
                          :test #'same)
              (cond ((clause 2) (apply #'collect binding))
                    ((clause 3) (collect 1st 2nd :into 3rd))
                    ((clause 4 (3rd into)) (collect 1st 2nd :into 4th)))
              (apply #'collect binding)
              (go next-loop))
            1-arg-clauses
            (when (member 1st '("NAMED" "REPEAT" "UNTIL" "WHILE" "ALWAYS" "NEVER" "THEREIS")
                          :test #'same)
              (apply #'collect binding)
              (go next-loop))
            cond-clauses
            (when (> (length binding) 3)
              (cond ((same (car binding) "WHEN")
                     (apply #'collect `(:when ,(second binding) ,@(for-collect-clauses (cddr binding)))))
                    ((same (car binding) "UNLESS")
                     (apply #'collect `(:unless ,(second binding) ,@(for-collect-clauses (cddr binding)))))
                    ((and (= (length binding) 4) (same 1st "IF"))
                     (apply #'collect `(:if ,(second binding) ,@(for-collect-clauses (list (third binding)))
                                         ,@(for-collect-clauses (list (fourth binding))))))
                    (t (go do-clauses)))
              (go next-loop))
            do-clauses
            (setq this-do-p t)
            (if last-do-p
                (collect binding)
              (collect :do binding))
            next-loop
            (setq last-do-p this-do-p
                  this-do-p nil)
            (setq bindings (rest bindings)
                  binding (car bindings))
            (when bindings (go start-loop)))))
      (cdr r))))

(defmacro for (&body body)
  (cons 'cl:loop (for-collect-clauses body)))

(defun for*-collect-clauses (body)
  (let ((first-clause (for-collect-clauses (list (first body)))))
    (if (member (first first-clause) '(:do :if :when :unless))
        (for-collect-clauses body)
      `(,@first-clause :do (cl:loop ,@(for-collect-clauses (rest body)))))))

(defmacro for* (&body body)
  (cons 'cl:loop (for*-collect-clauses body)))

(export '(for for*))

#+lispworks
(editor:setup-indent "for" 0 5)
#+lispworks
(editor:setup-indent "for*" 0 6)